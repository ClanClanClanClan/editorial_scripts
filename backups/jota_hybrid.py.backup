#!/usr/bin/env python3
"""
Hybrid Selenium+Playwright approach for JOTA journal scraping.
Since JOTA and MAFE use the same platform, this uses similar strategies.
"""

import os
import time
import logging
import asyncio
import json
from typing import Dict, List, Optional, Any
from pathlib import Path

# Selenium imports
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException
import undetected_chromedriver as uc

# Playwright imports
from playwright.async_api import async_playwright, Page, Browser, BrowserContext
from playwright.async_api import TimeoutError as PlaywrightTimeoutError

# Local imports
from core.credential_manager import get_credential_manager
from bs4 import BeautifulSoup
import re

logger = logging.getLogger(__name__)

class JOTAHybridScraper:
    """
    Hybrid scraper for JOTA using both Selenium and Playwright.
    Similar to MAFE but adapted for JOTA's specific structure.
    """
    
    def __init__(self, debug: bool = True):
        self.debug = debug
        self.selenium_driver = None
        self.playwright_page = None
        self.playwright_browser = None
        self.playwright_context = None
        self.playwright_engine = None
        
        # URLs
        self.base_url = "https://jota.editorialmanager.com/"
        self.login_url = "https://jota.editorialmanager.com/login.asp"
        self.main_url = "https://jota.editorialmanager.com/default2.aspx"
        
        # Get credentials
        cred_manager = get_credential_manager()
        jota_creds = cred_manager.get_journal_credentials("JOTA")
        self.username = jota_creds.get('username')
        self.password = jota_creds.get('password')
        
        if not self.username or not self.password:
            raise ValueError("JOTA credentials not found in credential manager")
    
    async def setup_playwright(self):
        """Initialize Playwright with enhanced stealth settings"""
        try:
            self.playwright_engine = await async_playwright().start()
            
            # Launch browser with anti-detection settings
            self.playwright_browser = await self.playwright_engine.chromium.launch(
                headless=False,
                args=[
                    '--disable-blink-features=AutomationControlled',
                    '--disable-dev-shm-usage',
                    '--disable-gpu',
                    '--no-sandbox',
                    '--disable-setuid-sandbox',
                    '--disable-extensions',
                    '--disable-plugins',
                    '--disable-web-security',
                    '--disable-features=VizDisplayCompositor',
                    '--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    '--window-size=1920,1080'
                ]
            )
            
            # Create context with human-like behavior
            self.playwright_context = await self.playwright_browser.new_context(
                viewport={'width': 1920, 'height': 1080},
                user_agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                java_script_enabled=True,
                ignore_https_errors=True,
                extra_http_headers={
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Connection': 'keep-alive',
                    'Upgrade-Insecure-Requests': '1',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'none',
                    'Sec-Fetch-User': '?1',
                    'Cache-Control': 'max-age=0'
                }
            )
            
            # Advanced anti-detection script
            await self.playwright_context.add_init_script("""
                // Remove webdriver property
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => undefined,
                });
                
                // Mock plugins
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [
                        {
                            0: {type: "application/x-google-chrome-pdf", suffixes: "pdf", description: "Portable Document Format", enabledPlugin: Plugin},
                            description: "Portable Document Format",
                            filename: "internal-pdf-viewer",
                            length: 1,
                            name: "Chrome PDF Plugin"
                        },
                        {
                            0: {type: "application/pdf", suffixes: "pdf", description: "", enabledPlugin: Plugin},
                            description: "",
                            filename: "mhjfbmdgcfjbbpaeojofohoefgiehjai",
                            length: 1,
                            name: "Chrome PDF Viewer"
                        },
                        {
                            0: {type: "application/x-nacl", suffixes: "", description: "Native Client Executable", enabledPlugin: Plugin},
                            1: {type: "application/x-pnacl", suffixes: "", description: "Portable Native Client Executable", enabledPlugin: Plugin},
                            description: "",
                            filename: "internal-nacl-plugin",
                            length: 2,
                            name: "Native Client"
                        }
                    ],
                });
                
                // Mock languages
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['en-US', 'en'],
                });
                
                // Mock chrome object
                window.chrome = {
                    runtime: {},
                    loadTimes: function() {
                        return {
                            commitLoadTime: 1484781400.646,
                            connectionInfo: "http/1.1",
                            finishDocumentLoadTime: 1484781400.791,
                            finishLoadTime: 1484781400.791,
                            firstPaintAfterLoadTime: 0,
                            firstPaintTime: 1484781400.712,
                            navigationType: "Other",
                            npnNegotiatedProtocol: "unknown",
                            requestTime: 1484781400.593,
                            startLoadTime: 1484781400.621,
                            wasAlternateProtocolAvailable: false,
                            wasFetchedViaSpdy: false,
                            wasNpnNegotiated: false
                        };
                    },
                    csi: function() {
                        return {
                            onloadT: 1484781400791,
                            startE: 1484781400593,
                            tran: 15
                        };
                    }
                };
                
                // Mock permissions
                Object.defineProperty(navigator, 'permissions', {
                    get: () => ({
                        query: () => Promise.resolve({ state: 'granted' }),
                    }),
                });
                
                // Mock connection
                Object.defineProperty(navigator, 'connection', {
                    get: () => ({
                        downlink: 10,
                        effectiveType: '4g',
                        rtt: 50,
                        saveData: false,
                    }),
                });
                
                // Override toString methods
                window.navigator.webdriver = undefined;
                
                // Random mouse movements to appear human
                setInterval(() => {
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    const event = new MouseEvent('mousemove', {
                        clientX: x,
                        clientY: y
                    });
                    document.dispatchEvent(event);
                }, 5000 + Math.random() * 5000);
            """)
            
            self.playwright_page = await self.playwright_context.new_page()
            
            # Set additional page properties
            await self.playwright_page.set_extra_http_headers({
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Cache-Control': 'max-age=0',
                'Upgrade-Insecure-Requests': '1'
            })
            
            if self.debug:
                logger.info("Playwright setup complete for JOTA")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to setup Playwright for JOTA: {e}")
            return False
    
    def setup_selenium(self):
        """Initialize Selenium with enhanced stealth"""
        try:
            # Configure Chrome options for stealth
            options = uc.ChromeOptions()
            
            # Basic stealth options
            options.add_argument('--disable-blink-features=AutomationControlled')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-setuid-sandbox')
            options.add_argument('--disable-extensions')
            options.add_argument('--disable-plugins')
            options.add_argument('--disable-web-security')
            options.add_argument('--disable-features=VizDisplayCompositor')
            options.add_argument('--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
            options.add_argument('--window-size=1920,1080')
            
            # Additional stealth options
            options.add_argument('--disable-background-timer-throttling')
            options.add_argument('--disable-backgrounding-occluded-windows')
            options.add_argument('--disable-renderer-backgrounding')
            options.add_argument('--disable-field-trial-config')
            options.add_argument('--disable-back-forward-cache')
            options.add_argument('--disable-ipc-flooding-protection')
            
            # Create unique profile directory
            profile_dir = Path.home() / ".jota_chrome_profile" / str(int(time.time()))
            profile_dir.mkdir(parents=True, exist_ok=True)
            options.add_argument(f'--user-data-dir={profile_dir}')
            
            # Exclude automation switches
            options.add_experimental_option("excludeSwitches", ["enable-automation"])
            options.add_experimental_option('useAutomationExtension', False)
            
            # Set preferences
            prefs = {
                'profile.default_content_setting_values.notifications': 2,
                'profile.default_content_settings.popups': 0,
                'profile.managed_default_content_settings.images': 2,
                'profile.default_content_setting_values.plugins': 1,
                'profile.content_settings.plugin_whitelist.adobe-flash-player': 1,
                'profile.content_settings.exceptions.plugins.*,*.per_resource.adobe-flash-player': 1
            }
            options.add_experimental_option('prefs', prefs)
            
            # Initialize undetected Chrome
            self.selenium_driver = uc.Chrome(options=options, version_main=None)
            
            # Execute stealth script
            self.selenium_driver.execute_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => undefined,
                });
                
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5],
                });
                
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['en-US', 'en'],
                });
                
                window.chrome = {
                    runtime: {},
                };
            """)
            
            if self.debug:
                logger.info("Selenium setup complete for JOTA")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to setup Selenium for JOTA: {e}")
            return False
    
    async def playwright_stealth_navigation(self, url: str) -> bool:
        """Navigate with human-like behavior using Playwright"""
        try:
            # Navigate with random delays
            await self.playwright_page.goto(url, wait_until='load', timeout=30000)
            
            # Random delay to appear human
            await asyncio.sleep(2 + random.uniform(0.5, 2.0))
            
            # Scroll randomly
            await self.playwright_page.evaluate("""
                window.scrollTo(0, Math.random() * 200);
            """)
            
            await asyncio.sleep(1 + random.uniform(0.2, 0.8))
            
            # Move mouse randomly
            await self.playwright_page.mouse.move(
                random.randint(100, 800),
                random.randint(100, 600)
            )
            
            return True
            
        except Exception as e:
            logger.error(f"Playwright navigation failed: {e}")
            return False
    
    async def playwright_login_attempt(self) -> bool:
        """Enhanced Playwright login with human-like behavior"""
        try:
            # Navigate to login page with stealth
            if not await self.playwright_stealth_navigation(self.login_url):
                return False
            
            # Wait for page to be ready
            await self.playwright_page.wait_for_load_state('networkidle', timeout=15000)
            
            # Look for login form
            await asyncio.sleep(1 + random.uniform(0.5, 1.5))
            
            # Try to find username field
            username_selectors = [
                '#username',
                '[name="username"]',
                'input[type="text"]',
                '[id*="user"]',
                '[name*="user"]'
            ]
            
            username_element = None
            for selector in username_selectors:
                try:
                    username_element = await self.playwright_page.query_selector(selector)
                    if username_element:
                        is_visible = await username_element.is_visible()
                        if is_visible:
                            break
                except:
                    continue
            
            if not username_element:
                logger.error("Username field not found with Playwright")
                return False
            
            # Human-like typing
            await username_element.click()
            await asyncio.sleep(random.uniform(0.1, 0.3))
            await username_element.clear()
            await asyncio.sleep(random.uniform(0.1, 0.3))
            
            # Type with random delays
            for char in self.username:
                await username_element.type(char)
                await asyncio.sleep(random.uniform(0.05, 0.15))
            
            # Find password field
            password_selectors = [
                '#passwordTextbox',
                '#password',
                '[name="password"]',
                'input[type="password"]',
                '[id*="pass"]',
                '[name*="pass"]'
            ]
            
            password_element = None
            for selector in password_selectors:
                try:
                    password_element = await self.playwright_page.query_selector(selector)
                    if password_element:
                        is_visible = await password_element.is_visible()
                        if is_visible:
                            break
                except:
                    continue
            
            if not password_element:
                logger.error("Password field not found with Playwright")
                return False
            
            # Human-like password entry
            await password_element.click()
            await asyncio.sleep(random.uniform(0.1, 0.3))
            await password_element.clear()
            await asyncio.sleep(random.uniform(0.1, 0.3))
            
            # Type password with random delays
            for char in self.password:
                await password_element.type(char)
                await asyncio.sleep(random.uniform(0.05, 0.15))
            
            # Wait before submitting
            await asyncio.sleep(random.uniform(0.5, 1.0))
            
            # Find and click submit button
            submit_selectors = [
                '[name="editorLogin"]',
                '[value="Editor Login"]',
                'input[type="submit"]',
                'button[type="submit"]',
                '[id*="login"]'
            ]
            
            for selector in submit_selectors:
                try:
                    submit_element = await self.playwright_page.query_selector(selector)
                    if submit_element:
                        is_visible = await submit_element.is_visible()
                        if is_visible:
                            await submit_element.click()
                            logger.info(f"Clicked submit with Playwright: {selector}")
                            break
                except:
                    continue
            
            # Wait for navigation
            await self.playwright_page.wait_for_load_state('networkidle', timeout=30000)
            
            # Check if login was successful
            current_url = self.playwright_page.url
            page_content = await self.playwright_page.content()
            
            success_indicators = [
                'Associate Editor',
                'default2.aspx',
                'dashboard',
                'manuscripts',
                'editor'
            ]
            
            login_success = any(indicator.lower() in page_content.lower() for indicator in success_indicators)
            url_success = any(indicator in current_url.lower() for indicator in ['default2', 'dashboard', 'main'])
            
            if login_success or url_success:
                logger.info("Playwright login successful for JOTA")
                return True
            else:
                logger.error("Playwright login failed for JOTA")
                return False
                
        except Exception as e:
            logger.error(f"Playwright login attempt failed: {e}")
            return False
    
    def selenium_enhanced_login(self) -> bool:
        """Enhanced Selenium login with stealth"""
        try:
            # Navigate to login page
            self.selenium_driver.get(self.login_url)
            
            # Random delay
            time.sleep(2 + random.uniform(0.5, 2.0))
            
            # Scroll randomly
            self.selenium_driver.execute_script(f"window.scrollTo(0, {random.randint(0, 200)});")
            time.sleep(random.uniform(0.5, 1.0))
            
            # Find username field
            username_field = None
            username_selectors = [
                (By.ID, "username"),
                (By.NAME, "username"),
                (By.CSS_SELECTOR, 'input[type="text"]'),
                (By.CSS_SELECTOR, '[id*="user"]'),
                (By.CSS_SELECTOR, '[name*="user"]')
            ]
            
            for by, selector in username_selectors:
                try:
                    username_field = WebDriverWait(self.selenium_driver, 5).until(
                        EC.presence_of_element_located((by, selector))
                    )
                    if username_field.is_displayed():
                        break
                except:
                    continue
            
            if not username_field:
                logger.error("Username field not found with Selenium")
                return False
            
            # Human-like interaction
            username_field.click()
            time.sleep(random.uniform(0.1, 0.3))
            username_field.clear()
            time.sleep(random.uniform(0.1, 0.3))
            
            # Type with random delays
            for char in self.username:
                username_field.send_keys(char)
                time.sleep(random.uniform(0.05, 0.15))
            
            # Find password field
            password_field = None
            password_selectors = [
                (By.ID, "passwordTextbox"),
                (By.ID, "password"),
                (By.NAME, "password"),
                (By.CSS_SELECTOR, 'input[type="password"]'),
                (By.CSS_SELECTOR, '[id*="pass"]'),
                (By.CSS_SELECTOR, '[name*="pass"]')
            ]
            
            for by, selector in password_selectors:
                try:
                    password_field = WebDriverWait(self.selenium_driver, 5).until(
                        EC.presence_of_element_located((by, selector))
                    )
                    if password_field.is_displayed():
                        break
                except:
                    continue
            
            if not password_field:
                logger.error("Password field not found with Selenium")
                return False
            
            # Human-like password entry
            password_field.click()
            time.sleep(random.uniform(0.1, 0.3))
            password_field.clear()
            time.sleep(random.uniform(0.1, 0.3))
            
            # Type password with random delays
            for char in self.password:
                password_field.send_keys(char)
                time.sleep(random.uniform(0.05, 0.15))
            
            # Wait before submitting
            time.sleep(random.uniform(0.5, 1.0))
            
            # Find and click submit button
            submit_selectors = [
                (By.NAME, "editorLogin"),
                (By.XPATH, "//input[@value='Editor Login']"),
                (By.CSS_SELECTOR, 'input[type="submit"]'),
                (By.CSS_SELECTOR, 'button[type="submit"]'),
                (By.CSS_SELECTOR, '[id*="login"]')
            ]
            
            for by, selector in submit_selectors:
                try:
                    submit_btn = WebDriverWait(self.selenium_driver, 5).until(
                        EC.element_to_be_clickable((by, selector))
                    )
                    submit_btn.click()
                    logger.info(f"Clicked submit with Selenium: {selector}")
                    break
                except:
                    continue
            
            # Wait for navigation
            WebDriverWait(self.selenium_driver, 30).until(
                lambda d: any(indicator in d.page_source.lower() for indicator in [
                    'associate editor', 'default2.aspx', 'dashboard', 'manuscripts'
                ])
            )
            
            logger.info("Selenium login successful for JOTA")
            return True
            
        except Exception as e:
            logger.error(f"Selenium login attempt failed: {e}")
            return False
    
    async def hybrid_login(self) -> bool:
        """Perform hybrid login for JOTA"""
        try:
            # Setup both engines
            if not await self.setup_playwright():
                logger.error("Failed to setup Playwright for JOTA")
                return False
            
            if not self.setup_selenium():
                logger.error("Failed to setup Selenium for JOTA")
                return False
            
            # Try Playwright first with enhanced stealth
            logger.info("Attempting JOTA login with enhanced Playwright...")
            if await self.playwright_login_attempt():
                return True
            
            # If Playwright fails, try enhanced Selenium
            logger.info("Playwright login failed, trying enhanced Selenium...")
            if self.selenium_enhanced_login():
                return True
            
            # If both fail, try iframe approach
            logger.info("Both direct logins failed, trying iframe approach...")
            return self.selenium_iframe_login()
            
        except Exception as e:
            logger.error(f"Hybrid login failed for JOTA: {e}")
            return False
    
    def selenium_iframe_login(self) -> bool:
        """Handle iframe-based login for JOTA"""
        try:
            self.selenium_driver.get(self.main_url)
            time.sleep(3 + random.uniform(0.5, 2.0))
            
            # Find all iframes
            iframes = self.selenium_driver.find_elements(By.TAG_NAME, "iframe")
            logger.info(f"Found {len(iframes)} iframes in JOTA")
            
            for i, iframe in enumerate(iframes):
                try:
                    iframe_src = iframe.get_attribute("src")
                    if self.debug:
                        logger.info(f"Checking JOTA iframe {i+1}: {iframe_src}")
                    
                    # Switch to iframe
                    self.selenium_driver.switch_to.frame(iframe)
                    time.sleep(1 + random.uniform(0.2, 0.8))
                    
                    # Look for login fields
                    username_field = None
                    password_field = None
                    
                    # Try multiple selectors
                    for by, selector in [(By.ID, "username"), (By.NAME, "username")]:
                        try:
                            username_field = self.selenium_driver.find_element(by, selector)
                            if username_field.is_displayed():
                                break
                        except:
                            continue
                    
                    for by, selector in [(By.ID, "passwordTextbox"), (By.ID, "password"), (By.NAME, "password")]:
                        try:
                            password_field = self.selenium_driver.find_element(by, selector)
                            if password_field.is_displayed():
                                break
                        except:
                            continue
                    
                    if username_field and password_field:
                        logger.info(f"Found login fields in JOTA iframe {i+1}")
                        
                        # Fill form with human-like behavior
                        username_field.click()
                        time.sleep(random.uniform(0.1, 0.3))
                        username_field.clear()
                        time.sleep(random.uniform(0.1, 0.3))
                        
                        for char in self.username:
                            username_field.send_keys(char)
                            time.sleep(random.uniform(0.05, 0.15))
                        
                        password_field.click()
                        time.sleep(random.uniform(0.1, 0.3))
                        password_field.clear()
                        time.sleep(random.uniform(0.1, 0.3))
                        
                        for char in self.password:
                            password_field.send_keys(char)
                            time.sleep(random.uniform(0.05, 0.15))
                        
                        # Find and click submit
                        try:
                            submit_btn = self.selenium_driver.find_element(By.NAME, "editorLogin")
                            time.sleep(random.uniform(0.3, 0.7))
                            submit_btn.click()
                            
                            # Switch back to main frame
                            self.selenium_driver.switch_to.default_content()
                            time.sleep(3)
                            
                            # Check success
                            if any(indicator in self.selenium_driver.page_source.lower() for indicator in [
                                'associate editor', 'dashboard', 'manuscripts'
                            ]):
                                logger.info("JOTA iframe login successful")
                                return True
                                
                        except Exception as e:
                            logger.error(f"Submit button error in JOTA iframe: {e}")
                    
                    # Switch back to main frame
                    self.selenium_driver.switch_to.default_content()
                    
                except Exception as e:
                    logger.error(f"Error with JOTA iframe {i+1}: {e}")
                    try:
                        self.selenium_driver.switch_to.default_content()
                    except:
                        pass
                    continue
            
            return False
            
        except Exception as e:
            logger.error(f"JOTA iframe login failed: {e}")
            return False
    
    def extract_manuscripts(self) -> List[Dict[str, Any]]:
        """Extract manuscripts from JOTA after successful login"""
        try:
            if not self.selenium_driver:
                logger.error("Selenium driver not initialized")
                return []
            
            manuscripts = []
            
            # Navigate to manuscripts page if needed
            current_url = self.selenium_driver.current_url
            if 'default2.aspx' not in current_url:
                self.selenium_driver.get(self.main_url)
                time.sleep(3)
            
            # Find manuscript table
            soup = BeautifulSoup(self.selenium_driver.page_source, 'html.parser')
            
            # Look for different table structures
            tables = soup.find_all('table')
            manuscript_table = None
            
            for table in tables:
                # Check if this looks like a manuscript table
                headers = table.find_all(['th', 'td'])
                if any('manuscript' in header.get_text().lower() for header in headers):
                    manuscript_table = table
                    break
            
            if not manuscript_table and tables:
                # Use the largest table as fallback
                manuscript_table = max(tables, key=lambda t: len(t.find_all('tr')))
            
            if not manuscript_table:
                logger.error("No manuscript table found in JOTA")
                return []
            
            # Extract manuscripts
            rows = manuscript_table.find_all('tr')
            for row in rows[1:]:  # Skip header row
                cells = row.find_all(['td', 'th'])
                if len(cells) >= 3:
                    try:
                        manuscript = {
                            'manuscript_id': cells[0].get_text(strip=True),
                            'title': cells[1].get_text(strip=True) if len(cells) > 1 else '',
                            'author': cells[2].get_text(strip=True) if len(cells) > 2 else '',
                            'status': cells[3].get_text(strip=True) if len(cells) > 3 else '',
                            'date': cells[4].get_text(strip=True) if len(cells) > 4 else '',
                            'referees': []
                        }
                        
                        # Extract referee information if available
                        if len(cells) > 5:
                            referee_text = cells[5].get_text(strip=True)
                            if referee_text:
                                manuscript['referees'] = [{'name': referee_text}]
                        
                        manuscripts.append(manuscript)
                        
                    except Exception as e:
                        logger.error(f"Error extracting JOTA manuscript row: {e}")
                        continue
            
            logger.info(f"Extracted {len(manuscripts)} manuscripts from JOTA")
            return manuscripts
            
        except Exception as e:
            logger.error(f"Error extracting JOTA manuscripts: {e}")
            return []
    
    def cleanup(self):
        """Clean up resources"""
        try:
            if self.selenium_driver:
                self.selenium_driver.quit()
            
            if self.playwright_context:
                asyncio.create_task(self.playwright_context.close())
            
            if self.playwright_browser:
                asyncio.create_task(self.playwright_browser.close())
            
            if self.playwright_engine:
                asyncio.create_task(self.playwright_engine.stop())
                
        except Exception as e:
            logger.error(f"Error during JOTA cleanup: {e}")
    
    async def scrape_manuscripts_and_emails(self) -> List[Dict[str, Any]]:
        """Main scraping method for JOTA using hybrid approach"""
        try:
            # Perform hybrid login
            if not await self.hybrid_login():
                logger.error("JOTA hybrid login failed")
                return []
            
            # Extract manuscripts
            manuscripts = self.extract_manuscripts()
            
            return manuscripts
            
        except Exception as e:
            logger.error(f"JOTA scraping failed: {e}")
            return []
        finally:
            self.cleanup()

# Import for random delays
import random

# Compatibility wrapper for existing code
class JOTAJournal:
    """Wrapper class for compatibility with existing JOTA code"""
    
    def __init__(self, driver=None, debug=True):
        self.driver = driver
        self.debug = debug
        self.hybrid_scraper = JOTAHybridScraper(debug=debug)
    
    def scrape_manuscripts_and_emails(self):
        """Main method for compatibility"""
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            result = loop.run_until_complete(
                self.hybrid_scraper.scrape_manuscripts_and_emails()
            )
            loop.close()
            return result
        except Exception as e:
            logger.error(f"JOTA hybrid scraping failed: {e}")
            return []